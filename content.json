{"meta":{"title":"KpLearner","subtitle":null,"description":null,"author":"AnHui","url":"https://huianyi.github.io"},"pages":[{"title":"Categories","date":"2016-08-11T04:12:45.000Z","updated":"2018-02-07T08:02:31.689Z","comments":true,"path":"categories/index.html","permalink":"https://huianyi.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-02-07T06:45:35.340Z","comments":true,"path":"tags/index.html","permalink":"https://huianyi.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-08-11T04:12:45.000Z","updated":"2018-02-07T06:52:01.128Z","comments":true,"path":"about/index.html","permalink":"https://huianyi.github.io/about/index.html","excerpt":"","text":"尚待更新… 联系方式github:https://github.com/huianyiemail: anh131@126.com"}],"posts":[{"title":"Zero","slug":"AlphaGo Zero - 为何可以工作和如何工作(翻)","date":"2018-03-07T07:08:43.000Z","updated":"2018-03-14T11:03:48.516Z","comments":true,"path":"2018/03/07/AlphaGo Zero - 为何可以工作和如何工作(翻)/","link":"","permalink":"https://huianyi.github.io/2018/03/07/AlphaGo Zero - 为何可以工作和如何工作(翻)/","excerpt":"","text":"AlphaGo Zero - 为何可以工作和如何工作作者：Tim Wheeler,PhD Candidate@StanfordDepartment of Aeronautics and stronauticsAutomotive AIwheelert@stanford.edu综述在2016年的3月，DeepMind的AlphaGo引起了世界的轰动，它成为了史上第一个在围棋上打败一位顶尖围棋高手的AI。当时该版本的AlphaGo——AlphaGo Lee，使用了大量围棋高手的棋谱来作为训练集。然而，最近一篇新的文章向我们介绍了新的神经网络——AlphaGo Zero，它并不需要人类来指导它如何下围棋(并不需要人类棋谱)。AlphaGo Zero不仅仅比所有的围棋棋手或机器下的好，更令人震惊的是，它只需要三天的训练时间。本文接下来将会为你解释它为何可以工作和它如何进行工作的。 蒙特卡洛树搜索让机器在离散、确定性游戏中获取完美信息的首选算法是蒙特卡洛树搜索(MCTS)。一个机器在下像围棋、象棋、棋盘格类游戏时，它会尝试所有位置，并猜测对手的所有应对结果，再考虑自己的应对…如此循环往复。对于像围棋这样的游戏来说，求解域的增长十分迅速。蒙特卡洛树搜索将会基于该位置有多好来进行选择性尝试，因此它只会聚焦于最有可能发生的那一结果。 从更技术的角度来讲，该算法思路如下：当前游戏进程状态为初始状态s0，并且假设现在到机器走下一步了。机器可以从行动集A中进行选择下一步，蒙特卡洛树搜索从一棵只有一个节点s0的树开始。这个节点通过尝试每个$a\\in A$来进行子节点的扩展，如下是一字棋的蒙特卡洛树实例： 每一个子节点的价值都将会在接下来的步骤中决定，该价值是通过对当前子节点状态进行随机落子直至胜局、平局或败局的出现，胜局加一分，败局减一分，平局为0. 如上图所示，是s0子节点1的随机运行结果，该结果致使子节点1的价值为1。这个价值并不是代表着优解，因为该价值会随着随机运行过程而进行变化。一个机器运行是可以非智能的，每一步落子随机。但机器也可以通过更好的策略（虽然这个策略也是随机的）或者通过直接估计当前运行的价值来运行的更好。下面我们就来介绍这种情况。 上图是我们给每个子节点通过估计值所得到的扩展树。值得注意的是我们新增了两种属性值：累计值W和该结果被访问到的次数N。由上可知，我们仅访问每个节点一次。 从子节点上得到的信息通过汇总来表示父节点的值： 蒙特卡洛树搜索通过选择节点、扩展该节点、收集更新该节点信息来完成多次迭代。蒙特卡洛树搜索并不会扩展所有的叶子节点，因为这样的花销是巨大的。相反，选择节点过程往往是在那些有很高估计价值和相对未经过开发————即访问次数少之间取得平衡。 叶子节点的选择是从根向下遍历，然后找到有着最高upper confidence tree(UCT)分数的子节点i： U_i=\\frac{W_i}{N_i}+c\\sqrt{\\frac{lnN_p}{N_i}}$W_i$是子节点i的累计值，$N_i$是子节点i的访问次数,$N_p$是其父节点的访问次数。而参数$c$则控制着选择最高估计值(c小的时候)和未开发值(c高的时候)之间的平衡。它通常是由经验决定的。 在$c=1$时，一字棋的UCT分数如下： 如上所示，我们将会选择$s_{0,1}$，该节点将会被扩展和更新： 可以观察到，每个累计值W都反映着X的输赢。在选择过程中，我们将会持续跟踪它是X落子还是O落子，如果是O落子，那么W的值与上图相反。 蒙特卡洛树将会一直迭代直到规定的时间结束。树逐渐扩展，我们将在这些所有可以落子的方式中选择最佳方式。机器将会在实际过程中选择具有最高访问次数的节点情况去落子。比如，如果我们最终结果如下： 那么机器就会选择$s_{0,1}$进行下一步行动 专家策略提高效率像象棋和围棋这样的游戏有很大的分支。在一个确定的游戏状态下，我们会有很多可以落子的情况，而这导致我们很难充分的探知未来游戏状态。事实上，象棋大概有$10^{46}$中可能结果，而围棋在通常$19\\times 19$的情况下有大概$10^{171}$种可能(一字棋仅5478种可能) 仅仅通过普通的蒙特卡洛树搜索不足以有效评估落子情况。我们需要一种方法来(让搜索)更关注值得走的落子情况 假设我们有一个专家策略$\\pi$，对于当前给定状态，它可以告诉我们有多大可能性专家水准的棋手会走这一步。对于一字棋来说，结果可能如下： 其中$P_i = \\pi(a_i|s_0)$，表明在状态$s_0$的情况下有多大可能选择行动$a_i$。 如果在专家策略足够可靠的情况下，那么我们就可以制造出十分强大的机器，直接通过专家策略值来进行下一步落子。然而，得到专家策略十分困难，另一方面，证明该策略足够可靠也不容易。 幸运的是，我们可以通过修改过的蒙特卡洛树搜索(添加了专家策略)来提升速度。修改过的蒙特卡洛树将会根据专家策略存储每个节点访问可能性，然后该可能性将会用于在选择过程用于调整节点分数。DeepMind所用的The probabilistic upper confidence tree分数为： U_i=\\frac{W_i}{N_i}+cP_i\\sqrt{lnN_p}{1+N_i}在之前，分数是由最高估计值和最未开发之间权衡决定，而现在搜索则被专家策略引导，更偏向于专家策略认为好的的行动。如果专家策略足够好，那么蒙特卡洛树就会更有效地偏向于优的游戏状态。如果专家策略比较差，那么蒙特卡洛树搜索则会偏向于差的游戏状态。无论哪种情况，在迭代次数足够大(即树也不断扩展过程下)，节点的分数将会被胜率(即$W_i/N_i$)决定，和之前的公式一样。 值估计来提高效率通过避免昂贵并且潜在不精确的随机搜索是提升效率的另一类方法。一种是用之前提到的专家策略引导随机搜索，在策略很好的情况下，搜索会取得很好的结果。 另一种方案是直接避免搜索，并且直接通过估计函数$\\hat(W)(x)$估计当前状态值。该函数不经过随机落子估计，直接根据当前状态计算出一个介于-1到1之间的值。显然，如果$\\hat(W)$能对实际状态值达到很好的估计，而且执行速度快于随机落子估计，那么在不影响结果的情况下执行时间将会大大节省。 值估计和专家策略的结合可以加速蒙特卡洛树搜索。但仍旧有一个问题存在————我们怎样得到值估计函数和专家策略？有没有相关算法存在？ Alpha Zero神经网络Alpha Zero算法通过加速蒙特卡洛树搜索不断相互对抗从而得到了越来越好的专家策略和值估计函数。专家函数$\\pi$和值估计函数$\\hat(W)$通过深度神经网络得到。事实上，为了提高效率，Alpha Zero仅用一个神经网络$f$通过对当前状态$s$分析来得到下一步可能值(即$\\pi$)和值估计函数(即$\\hat(W)$)。 f(s)\\to [p,W]叶子节点通过神经网络的值得到评估，进而进行扩展。每一个子节点都会被初始化为$N=0,W=0$，P值则通过神经网络得到估计。预测值也会赋给被扩展节点的值，并且该值最终将会记录在树中。 选择过程和更新过程并没有变化。简单的说，在更新过程中，父节点的访问次数是递增的，它的值也会根据$W$来增加。 搜索树新一轮迭代情况如下： Alpha Zero算法的核心亮点是预测神经网络是可以提高的，通过蒙特卡洛树搜索的结果可以作为训练集。神经网络的策略部分通过训练对于状态$s_0$的预测可能性值$p$来匹配从状态$s_0$下的蒙特卡洛树搜索中获得的提升可能性值$\\pi$来得到提高。通过蒙特卡洛树搜索，提高后的策略预测值$p$为： \\pi{_i}=N_{i}^{1/\\tau}对于连续值$\\tau$，其越接近于0则使得策略选择根据蒙特卡洛树搜索评估得到的最好行动。 神经网络的值估计部分通过训练预测值来匹配最终的游戏结果，Z。他们的损失函数为： (W-Z)^2+\\pi{^T}lnp+\\lambda\\begin{Vmatrix}\\theta\\end{Vmatrix}","categories":[],"tags":[]},{"title":"PythonCaseWorkNotes","slug":"PythonCaseWorkNotes","date":"2018-02-10T14:41:00.000Z","updated":"2018-03-07T07:07:22.803Z","comments":true,"path":"2018/02/10/PythonCaseWorkNotes/","link":"","permalink":"https://huianyi.github.io/2018/02/10/PythonCaseWorkNotes/","excerpt":"这篇笔记是根据Python练习册的练习总结，主要讲了一些常用的语法错误和在变成过程中出现的问题，希望自己在以后的使用过程中能够犯更少的错误，在python编程之路上取得更大的进步！！ 如果这篇文章可以帮助到大家，那就再好不过了！！ 相关代码可见于我的github中 持续更新中……","text":"这篇笔记是根据Python练习册的练习总结，主要讲了一些常用的语法错误和在变成过程中出现的问题，希望自己在以后的使用过程中能够犯更少的错误，在python编程之路上取得更大的进步！！ 如果这篇文章可以帮助到大家，那就再好不过了！！ 相关代码可见于我的github中 持续更新中…… 图片角标添加代码及解释作为练习册的第一个问题，代码量很少，如下所示： 1234567891011from PIL import Image,ImageFont,ImageDrawim = Image.open(r'盘符:/PythonCaseWork/图片未读小标/raw.jpg')w,h = im.sizew = 5 * w / 6h = 1 * h / 6font = ImageFont.truetype(r'arial.ttf',30)draw = ImageDraw.Draw(im)draw.text((w,h),text='12',font=font,fill=(0,85,85,0))im.save(r'盘符:/PythonCaseWork/图片未读小标/modified.jpg')print('succeed!') 首先读取图片，取得图片的width和height，方便后续确定放置图片角标位置，接着读取特定的字体文件，然后通过ImageDraw.Draw()方法取得可用于绘制的图像。最后输出文件即可。 遇到的问题和解决方案 Visual Studio Code 读取python文件是从python下载目录里开始，为了解决这个问题，使用了绝对路径的方法。 读取字体文件时，要注意不同的字体文件类型有不同的读取方案，如PIL官网所说： load() : Load a font file. This function loads a font object from the given bitmap font file, and returns the corresponding font object. truetype() : Load a TrueType or OpenType font from a file or file-like object, and create a font object. This function loads a font object from the given file or file-like object, and creates a font object for a font of the given size. 注： 官方文档请见这里。 激活码生成器代码及解释代码如下： 123456789101112131415161718192021import randomimport stringimport redef isNumber(rawStr): pat = re.compile('^\\d+$') if pat.match(rawStr) is None: return 0 else: return 1if __name__ == '__main__': num = '' while isNumber(num) == 0: num = input('Please input the number of codes you need:') pass digit = '' while isNumber(digit) == 0: digit = input('Please input your activation code digits:') for i in range(int(num)): result = random.sample(string.ascii_letters + string.digits,int(digit)) print('the result is ' + ''.join(result)) 这个问题同样十分简单，首先是检测完整性输入情况，接着使用random类的sample()方法获得结果，输出即可。 遇到的问题和解决方案 还可以使用uuid类来生成激活码（充分显示了Python的强大） 3、4题比较简单，这里就跳过了。 单词统计次数代码及解释代码如下： 1234567891011121314151617181920212223import rewordsList = []wordsCounts = &#123;&#125;with open(r'E://PythonCaseWork/words count/text.txt','r') as f: isEnd = 0 while isEnd == 0: line = f.readline().lower() if line == '': isEnd = 1 continue tempList = re.split(r'[^a-zA-Z\\-]',line) for item in tempList: if len(item) == 1: continue if item not in wordsList: wordsList.append(item) wordsCounts[item] = 1 else: wordsCounts[item] = wordsCounts[item] + 1 passprint(wordsCounts) 通过读取每行为一个循环，在这次循环过程中，通过re库的split函数来实现多种不同字符的切割，进而剔除掉标点符号、空格等非英文字符，切割完成后删掉只有一个字母的item，实现最终效果。 遇到的问题和解决方案 在字符的切割过程中，Python自带的split函数和re库中的split函数不同，Python自带的split函数只能进行简单字符的切割，而不能实现多个字符的切割，而re则更强大，可以进行不同字符匹配切割，比如说下面这个例子： 1234string = 'a abc _d e'list1 = string.split(' ') # the result is ['a', 'abc', '', '_d', 'e']list2 = re.split(' ',string) # the result is ['a', 'abc', '', '_d', 'e']list3 = re.split(r'[ _]',string) # the result is ['a', 'abc', '', '', 'd', 'e'], which function split() can't do it. 统计日记中最重要的词问题和解决方案由于代码量较多，贴出来影响阅读体验，这里主要说明思路即可： 阅读本题可以发现，最核心只有两点： 所有日记，因此可以想到要读取所有目录文件 日记中最重要的词语，可以想从该篇文章中词频最高下手 解决方案读取文章目录可以使用如下几种方法： os.walk()函数读取 glob进行读取 具体可以参考这里 统计词频可以使用上一个问题中的统计单词数量部分代码，思路大致一样，注意一点就是对于stop word的处理，诸如I、is等对于文章影响不大的单词应当排除，只需要加入判断即可。 验证码生成器代码在书写过程中并未遇到相应问题，这里不再赘述，只罗列出相关文档即可 PIL库 Image,ImageDraw, ImageFont, ImageFilter random 库生成字母","categories":[{"name":"编程","slug":"编程","permalink":"https://huianyi.github.io/categories/编程/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"https://huianyi.github.io/tags/Python/"}]},{"title":"新资本论笔记","slug":"新资本论笔记","date":"2018-02-07T07:29:42.222Z","updated":"2018-02-07T07:51:01.398Z","comments":true,"path":"2018/02/07/新资本论笔记/","link":"","permalink":"https://huianyi.github.io/2018/02/07/新资本论笔记/","excerpt":"新资本论读书笔记","text":"新资本论读书笔记 自序 金融资产的规模和价格涨幅远远超过真实国内生产总值、人均可支配收入和人均工资的增长速度——脱实向虚现象 表现形式： 金融业对国内生产总值的贡献度越来越大。 金融业的地位从实体经济的“仆人”变成“主人”，虚拟经济和虚拟资本主导和支配着实体经济和物质资本的投资和积累，货币和金融市场成为了最具威慑力的市场。 利率和汇率等最重要的价格信号和实体经济的基本面脱节，资产市场和金融市场的投机和预期决定汇率和利率，它们反过来左右和决定实体经济的投资和消费。 虚拟经济和虚拟资本的积累速度远远超过真实国内生产总值、人均可支配收入和人均工资的增速，导致收入差距和贫富分化日益恶化。 当代人类的经济体系： 虚拟经济和实体经济的两极分化； 真实收入和财富分配的两极分化； 信用资源分配的两极分化；三个两极分化互为条件，相互加强。 (一)全球金融资本主义的兴起 基础货币和债权货币 债务和债权的关系 第四章：“卖不掉”与“还不上”——躲不开的金融危机 每一次金融危机的起点，都是偶然事件。每一次金融危机的背后，都有必然的规律 避免大规模产品滞销只有两个选择： 引进新的投资 提高消费能力（根本） 经济复苏的根源是设备更新，社会投资需求大规模增加；经济崩溃的的起点是大规模设备更新的完成，产能被释放出来。 未来现金流：一种债权，是企业向社会征集资金，并承诺给予相应的收益，销售产品偿还贷款，其他社会成员保留资金所有权交出使用权，获得相应收益。 每一种理财产品都会在不起眼的地方有明确表述投资风险自担的条款。这些不起眼条款会在需要的时刻发挥明确的作用。 把金融危机的根源归结为个别金融机构忽视风险，违规操作，而不是资本主义内生的缺陷的人，如果不是智力和猴子处于同一水平的话，就是利欲熏心看不到事情的本来面目，或者是为了利润故意视而不见。 金融的奥义就是利益归自己，风险推出去。用别人的钱，玩自己的赌博，拿丰厚的年金，在崩溃前跳槽。 第五章：羊毛出在谁身上：财政再分配 国家刺激经济的做法效果并不理想：短期来说，国内需求水平会有一定的上升。但是，随着国家债务的到期，国家如果不想赖账的话，必然会增加税收负担。国内底层消费进一步压榨，将会面临更大的危机。 贫富差距过大，大量产品滞销，税收上升，政府借债压榨社会底层的消费能力，这样迟早会面临金融危机 第六章：欠债还钱——钱荒 资本主义生产的目的是积累财富，而不是满足消费需求，所以本身就具有回流不畅的隐患 一旦出现聚敛、节流，整个经济循环必然崩溃 资金外流，银行准备金相对不足，于是，各大银行收紧信贷，催收贷款。经济危机和资金外流，完全可以互为诱因，互相加剧。 第七章：开闸放水——央行的救市行为 崩溃型的危机是投资高潮的必然结果 新增投资大规模下降，产能与消费能力之间的缺口就会暴露出来 经济停滞的原因： 货币过紧，导致经济无法复苏 有效需求不足，导致经济无法复苏（调整收入分配结构，消除过大的贫富差距，提高有效需求水平） 第八章 银行中的银行：现代央行 央行 垄断了发钞权，成为全国所有储户的总金库和总会计， 为全社会提供总会计和总出纳服务， 于是拥有了第三个特殊的身份——全国金融资本的核心 金融市场的情报中心和秩序的维护者 央行的“三板斧”理论上使央行具有通过控制银行，间接控制权社会流通债权货币（主要是贷款）总量的能力。于是，央行具有了第五个身份——宏观经济的调控者 央行从商业银行中脱离出来，成为了中央政府直接或间接地下属 政府宏观调控的把手 央行常用的影响宏观金融的三个手段 贴现率 公开市场操作 调整准备金 银行可以怎么对待储户，央行就可以怎么对待银行 央行替政府垄断了发行权，提供了更方便透支的能力 第九章 饮鸩(zhen)止渴：经济刺激政策 当就业量增加时，总实际所得也要增加。当总实际所得增加时，总消费也要增加，但不如所得增加得那么多。所以，如果整个就业量都用于满足消费需求的增加量，雇主就要蒙受损失 随着货币不断流动，每轮交易激发的有效需求规模在不断的下降，循环规模越来越小。社会垄断程度越高，垄断资本利润率越高，规模衰减越快。因此，凯恩斯的注入有限货币就能激发一系列的消费能力这个理论是不正确的 第十章 飞舞的蝴蝶：温和通货膨胀 通货膨胀是有人吃亏，有人获利的过程 悬殊的贫富差距导致社会总消费能力相对潜在生产能力严重不足，造成严重失业 法币发行的过程是有一些人先获得，然后通过环环交易不断扩大流通范围。而商品也不是一瞬间同时、同步涨价的，币值也不是一瞬间下降到某个水平，而是一个经过逐步传导的过程。而且，不同商品价格上涨幅度和过程完全不同：有些商品价格是闻风而动，有些原地踏步；有些一飞冲天，有些小幅攀升，有些上去就下不来，有些暴涨后暴跌 物价上涨过程不是一步到位的，而是经过“政府订单产品”、“关键原材料”、“日用生活用品”、“劳动力”四个环节。前两个环节是注定盈利，是一种特权；后两个环节注定吃亏，不涨价就难以为继 通胀是一个底层吃亏、顶层发财，贫富差距扩大的过程 挤出效应和乘数效应（在垄断企业中出现成都较低） 第十一章 脱缰的野马：恶性通货膨胀 通货膨胀具有一旦启动就会加速发展的特点 影响法币价值的三个变量（？），最关键的是流通中的法币数量 抛开政权崩溃的情况外，自由市场经济的条件下，货币供应量过多是恶性通胀的充分必要条件 通胀初期，黄金、房产、外汇等特殊产品上涨的幅度往往超过其它产品 法币在通胀时期逐步失去其五大功能的过程；一般顺序为：价值储藏-&gt;流通手段-&gt;价值尺度-&gt;支付手段（往往和大宗交易在一起）\\国际货币功能 恶性通胀时期，囤积商品会成为有利可图的事情，于是每一轮囤积的起因都是法币贬值，每一轮囤积都加速物价上涨，通胀出现自我加速的趋势 物价上涨越快，法币流通速度越快 希望通过印钞给某些行业补贴，拉动这些行业扩张，必然导致其他商品（尤其是垄断商品）进一步上涨，恶性的结果如果不是某几种商品价格基本变化不大其它商品价格猛涨的话，就是所有商品的价格全部猛涨 控制物价/推动生产/控制货币流通速度/压缩流通中的法币数量（提供虚拟资本；用政府资产回收多余法币——池子理论；发行国债；增加税收；加息；法币推向外境），其中，只有法币推向外境有一定的可行性（但是，价值符号是暴力的象征，流通必须以暴力为后盾） 恶性通胀的根本原因是政府不停下印钞机，法币总量猛增。一切治理通胀的根本方法是让印钞机的转速降下来 恶性通胀过后，一旦物价稳定下来，社会总需求马上会陷入严重不足，往往出现大规模商品过剩。 相比之下，城市化率越高的国家，恶性通胀对政权的威胁性越大，多数人口在农村的国家则安稳的多 某种必需品因为其他外部原因导致价格飞涨，会唤醒休眠的货币（在储蓄率高的国家中尤其可怕），从而使流通中的法币总量大大增加，进而导致通货膨胀 第十二章 纸面富贵：虚拟资本 货币进入经济循环时，未必直接进入商品循环，可能暂时停留在虚拟资本市场，并在其中流动，形成一个“堰塞湖”，并不参与现实商品买卖。预示，可能出现货币数量增加，物价暂时按兵不动的现象。 虚拟资本所有人并不能具体指出那一部分显示资本是属于自己的 虚拟资本价值取决于两个变量：虚拟资本盈利能力；社会资金宽裕程度。 对于中小资本来说，对他们更有意义的利润率不是同行之间的利润率，而是银行存款利率。 对资本来说，利润率的下限是银行存款利率 一般来说，银行存款利率的变化方向，能直接反映各种利率的变化方向。银行存款利率的涨跌也就必然对应虚拟资本价格的涨跌。 虚拟资本的理想价格=股息、利息、红利、地租 / 存款利率 一般情况下，利率降低，股票、债券、房产价格升高。但是，个别情况下，利率极低时虚拟资本价格也有可能出现暴跌（经常出现在经济停滞期） 从长期看，中小资本经营利润的日益下降，必然导致虚拟资本价格不断的上升？ 对于小资本来说，用钱介个大资本产生“钱生钱”的途径外可用方法很少，因此，大资本在募集资金的博弈中占尽优势 虚拟资本成交的平均实际价格=购买的虚拟资本的货币总量/待售的资本数 虚拟资本的实际价格=购买虚拟资本的货币总量/出手的虚拟资本总量 第十三章 庞氏骗局：虚拟资本投机 虚拟资本是信用的一种，是一种特殊的资产，其市场价格经常发生剧烈波动，是理想的投机对象。很多人购买虚拟资本的目的就是以更高的价格卖出——虚拟资本投机 投机行为主要包括三种：不同时间、不同空间、不同人群之间的买卖 成规模的全民投机运动，如同一个自锁的机构，往往需要一个起点才能开始。这个起点，可能是政府在大规模撒钱推行经济刺激政策，也可能是其他。 价格虽然飙升，但是短期内却难以增加供应的商品容易成为投机品（相较而言，古玩和艺术品虽然数量稀少，但是与日用品而言难以形成全民运动） 当所有人参与投机的时候，必然出现一般商品生产萎缩，投机品供应过剩，最终投机品滞销的情况。（在垄断投机市场中同样适用） 投机品与实体经济循环结合越紧密，投机市场崩溃后对实体经济的冲击越严重 全民投资运动并不能带来全民致富，往往是多数人的财产向少数人手中转移。 历史上著名的三次投机运动 郁金香热 密西西比骗局 南海泡沫 第十四章 海市蜃楼：虚拟资本价格的波动性 虚拟资本投资，很大程度上依赖于各种公开的消息和对以往经验的判断。但是，这两者都是靠不住的，于是，虚拟资本很容易成为奇幻发财故事的载体。夸大未来收益能力从而圈到更多的金钱。 对投机者来说，卖出的价格越高越好，只要虚拟资本价格在不断上涨，投资虚拟资本就是合算的。但是，投资者接盘的目的是为了获得红利的收益，对投资者来说，买入的价格越低越好，价格高到一定程度就不再有吸引力了。 虚拟资本的盈利能力和社会中小资本平均利润率的变动都与经济周期有密切的联系。 利率价格暴涨，股票价格必然暴跌——因为许多人不得不变现资产，偿还债务。 在货币商场紧迫的时候，有价证券的价格会双重跌落： 利息率升高 这种有价证券大量投入市场，以便实现为货币 在资本主义条件下，虚拟资本市场也是市场的一部分，同样存在马太效应,也会出现资本不断自我集中强化的现象，遵循“强者恒强”的规律。 无论是在一级市场，还是二级商场，大资本都具有压倒性的优势。 一旦大型投机风暴过去，价格暴跌的证券就会回升到他们之前的水平，除非它们代表的是一个破产的或欺诈性质的企业。 只要紧缩货币，就能使经济循环初级信贷上限，进入结账状态。 第十五章 贫民窟中的银山：住房问题 决定虚拟资本价格的两个要素是虚拟资本的收益和利率 地租分为两部分，一部分是一个基准水平，一部分是各地收入水平的差额 经济的发展直接刺激沿海城市地区地租的发展，制造业不能承担地租，不得不向内陆转移。沿海地区地租上升到一定程度，也会拉动内陆地区的地租 地租比工资抗跌 地主阶级对内的统治会随着土地所有权的集中而日益动摇，对外则没有抵御外来工业社会冲击的自卫能力 第十六章 自然的权利：土地问题的实质 大土地所有权违背了多数人认可的“按劳分配，多劳多得”的原则 有意闲置一片土地，让一部分租户无法成交，则推动价格上涨的效果更好。（如：面包店只养活99%的人） 刚性需求必然与一个人的经济地位密切相关 单位面积的地租决定与租户的毛收入总量和土地所有者与租户双方博弈力量的对比，与人均面积没有多大关系 第十七章 滞胀沫崩：政府面临的金融乱局 垄断资本对中小资本有先天博弈优势，资本对劳动力有博弈优势 垄断时代，呈现出金字塔式的竞争模式，劳动力向资本贡献剩余价值，中小资本向垄断企业贡献利润，垄断企业握有大量现金无处投资，投资研发很可能得不偿失，反倒压缩产能谋取更大利润。 垄断资本控制生产生活必需品，所有投资、消费行为都离不开。任何需求很快都会转变成对垄断品的需求。 就业难和用工荒并存的原因就是劳动力价格上涨，但是中小企业利润颇微，难以为继 滞胀过程的四个必要条件 市场高度垄断 政府刺激市场经济试图避免萧条和崩溃 垄断企业影响政府决策 市场经济 中小企业是解决就业问题的主力，也是链条中最脆弱的部分 经济停滞期，一国的就业率决定于社会顶层的消费能力和社会底层被剥削的严重程度 第十八章 十字路口：社会主义的起点 经济停滞的原因是少数人博弈能力太清，获得的社会总产品分配份额太高，多数人博弈能力太差，分配份额太低。经济规模由有效需求决定，所以远远小于潜在产出。 私有化不过是改变了国有垄断资本的所有权，并不能达到削弱垄断、激活经济的目的。 第十九章 短板与瓶颈：支付能力和制约关系 从商品流动和产权关系看，二米次经济周期都是从生产复苏开始，到经济危机为止，都是一次大资本兼并小资本的过程。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/tags/笔记/"},{"name":"金融","slug":"金融","permalink":"https://huianyi.github.io/tags/金融/"}]},{"title":"Python_NoteBook","slug":"Python-NoteBook","date":"2016-08-05T04:02:00.000Z","updated":"2018-02-07T07:22:32.899Z","comments":true,"path":"2016/08/05/Python-NoteBook/","link":"","permalink":"https://huianyi.github.io/2016/08/05/Python-NoteBook/","excerpt":"","text":"基础知识 Python print()函数遇到逗号会输出一个空格，如print(&#39;A&#39;,&#39;B&#39;)则输出A b input(string)输入字符串 Python程序大小写敏感 print()函数可以使用r&#39;&#39;来表示不进行转义，还有&#39;&#39;&#39;...&#39;&#39;&#39;方法进行多行输入 Python的整数没有大小限制，浮点数也没有大小限制（超出一定范围就会显示为inf） Python是一种动态语言 ord()获取字符的整数表示chr()把编码转化对应的字符 在Python中，无法显示为ASCII的字符用\\x##表示 encode()编码decode()解码 len()函数可以计算字符数，也可以计算list的元素个数，但当遇到b&#39;xxxxx&#39;就计算字节数 在文档开头使用#-*- coding:utf-8 -*-来表示文档应使用utf-8格式解码 print()函数用于标准化输出时，无法进行计算功能 list相当于数组，可以存放任意类型的数据（包括数组），读取通过添加负号可以从后向前读取，常用函数如下: append()添加元素 insert(index,item)插入指定位置元素 pop(i)删除i位置的元素 Python中新增了类型tuple，是一种不变长度，数据的数组，从而保护数组安全，定义方法为：class=(1,23,4)，注意：定义一个元素的tuple时，为避免消除歧义，要加逗号，如class=(1,) Python写条件判断形式与一般不同，如下： 12345678if age&gt;18: print('your age is',age) print('adult')elif age&gt;=6: print('teenager')else: print('child')#if判断条件还可以简写成if x...的形式，一般来说，只要是非零数值，非空字符串，非空list，就判断为true，否则为false input()函数会将用户输入的数据转化为string类型，因此数据要使用int()函数进行转化 range()函数可以用于生成整数序列如range(101)生成从0-100的数，list()函数可以将其转化为数组 循环的两种使用方法： 1234567classmates=['Bone','An','Xi']for x in classmates: print(x)x=0while x&lt;len(classmates): print(classmates[x]) x++ dict是一种key-value的存储方式（类似于hash表）,可以通过in或者get方法来检测是否有这个key值：&#39;Bone&#39;in classmates,classmates.get(&#39;Bone&#39;),classmates.get(&#39;Bone&#39;,1)(最后一个是自己指定方法)，可以通过pop()方法删除元素，定义dict的方法为：classmates={1:&#39;Bone&#39;,2:&#39;An&#39;,3:&#39;Xi&#39;},另外，dict的key必须是不可变对象:string/整数等 函数名是指向函数的一个引用，完全可以用a=abs这种方式进行转换常用的函数： abs()：绝对值 int()/float()/str()/bool()/hex()（整数转十六进制）：数据类型的转换 isinstance(temp,(type1,type2,..))数据类型的检查 函数定义用def,一般函数没有返回语句的时候默认返回None，同时，函数返回允许返回多个数值 123456def test(a) x=a-1 y=a+1 return x,yx,y=test(5)#其实返回值是一个tuple 缺少了pass,如果么有写完全的话，就会出现错误 函数的参数由位置参数、默认参数（n=xx）（调用的时候可以采用直接写或者是（n=xx）的形式，但注意默认参数为list等可变变量的时候，如下1:）、可变参数（定义时加上*表示，相当于传入是一个tuple，调用时也可以直接使用*+tuple/listName的方法）、关键字参数（**+name的声明方法，相当于dict的形式，形式与可变参数类似）、命名关键字参数，如下2： 123456789101112131415161718191.def my_fun(L=[]): L.append(\"end\") return L &gt;&gt;&gt;my_fun(); [\"end\"] &gt;&gt;&gt;my_fun(); [\"end\",\"end\"] #因为默认参数是个变量，他指向了[]的地址 #更改如下 def my_fun(L=None): if L=None: L=[] L.append(\"end\")``` ```python def person(name,age,*,city=\"Beijing\",job) #定义方法,以*分开后边为命名关键字参数，可以有缺省值 person(\"Bone\",18，job=\"coder\") #调用时必须写明参数名称 参数组合的调用顺序为必选参数、默认参数、可变参数/命名关键字参数、关键字参数 高级特性 list/tuple/string切片方法L[index1:index2:interval] (支持负值) 任何可以迭代的类型都可以使用for in来进行迭代，通常，判断某个类型是否可以迭代用collections的Iterable模块进行，判断方式为：isinstance(temp,Iterable)。enumerate可以将list转化为索引-值的方式（如：for i,v in emunerate([&#39;a&#39;,&#39;b&#39;]):print(i,v)），另外，for in可以使用多个不同的变量：for x,y in xxxx dict的存储不是按照list的方式顺序排列 使用for in的方式迭代dic时，迭代的结果是key，如果要迭代value，可以使用for value in d.values()，如果两个都要迭代，可以使用for k,v in d.items()。 列表生成式直接创建list：[表达式 for循环 判断]（ep. [x*x for x in range(1,11) if x%2==0]） isinstance()函数是判断是否是某一类型（isinstance(A,str)） 一边循环一遍计算的机制，称为生成器（generator）生成器的特点如下: 两种生成方法：列表生成式将[]改为()，如：g=(x*x for x in range(11))。函数生成方法： 12345678 def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'#遇到yield停止执行，直到下次调用，要想得到返回值，必须抓取错误，stopIteration()函数 next函数获取下一生成值 生成器也是可以迭代的：for in循环可以使用 iterator和iterable的区别(生成器是iterator，也是iterable的，但是list、triple、dict为iterable)，可以使用iter()来转化 函数式编程 函数名也是变量 函数式编程就是让函数的参数接收函数，同时也支持返回值为函数，这样的函数是高阶函数。 map()函数、reduce()函数、filter()函数： map()函数和reduce()都是接收两个参数，且第一个参数为函数名，区别是执行顺序不一样，map是第二个参数中的iterable的每个值都执行一次，但是reduce则是将每两个值执行后，以结果和第三个进行运算。特别注意：map()函数的返回值是一个iterator filter()函数和map()函数接收参数和返回值都一样，不同的是filter是根据第一个参数返回值为true或者false来决定是否保留第二个参数的当前值。 sorted()函数进行排序函数，接收三个参数，第一个为一个list，第二个是key（即对list进行调整的参数），第三个是reverse=true/false。运行顺序为先key和reverse，然后是进行sort。 闭包和Javascript一样 匿名函数则与javascript不同，python中匿名以lambda表示，冒号前面为参数，后变为表达式，返回值为表达式内容。 装饰器，@语法 functools.partial(func-name,*args,**kw)相当于给func-name函数增加参数args，kw，并返回该函数，称之为偏函数 模块12345678910st=&gt;start: 父文件cond=&gt;condition: 有无__init__.pyop1=&gt;operation: 父文件为顶层包(也为模块)op3=&gt;operation: 父文件为普通文件op2=&gt;operation: 模块.pyst-&gt;cond-&gt;op1-&gt;op2cond(yes)-&gt;op1cond(no)-&gt;op3op3-&gt;op2 模块标准书写方式 12345#!/usr/bin/env python3# -*- coding:utf-8 -*-'文档说明，以模块文件的遇到的第一个字符串为文档说明，可以通过__doc__来调取'__author__='BoneAn'#以下为模块代码... 通过命令行调用模块，其__name__为__main__ sys.argv属性用list存储了命令行的所有参数 模块的作用域： __name__等的命名方式是特殊变量，一般不用于命名 private变量通过_XXX的方式来命名 第三方库的搜索网址为点击这里,python自带的第三方库下载工具为pip 添加模块，python搜索的路径可以通过sys.path找到 类 关键字为class，格式为class className(parentClassName) 一般会大写首字母 实例也可以有自己的属性，和静态语言不同 类的方法第一个参数必须为self 可以通过__init__方法来强制添加实例的必要属性 可以和模板的方式一样来设置私有变量 继承和多态与静态语言不同，只要是某个类与基类有相同的方法，就可以使用基类的相同的函数： 123456789 class Animal(object): def run(): print(\"is run!!\") class Car(object): def run(): print(\"car is run!\")def isRun(animal): animal.run() #isRun()函数car和animal都可以调用 getattr()、setattr()、hasattr()、dir()属性的应用 面向对象的高级编程 动态语言可以给实例添加方法，例：XX.name=MethodType(methodName,XX) 可以通过__slot__来限制给实例添加属性，例：__slot__=(&#39;name1&#39;,&#39;name2&#39;)#tuple,这样的只对当前类有作用，对子类无效 @property可以设置方法直接为属性，可以将方法设为只读属性，如： 12345678910111213 class Student(object): @property def name(self): return self.name @property def score(self): return self.score @score.setter def score(self,value): self.score=valueA=Student()A.score=40 #可以直接通过赋值，类似于属性一样# 但是name属性是只读的，因为它没有setter方法 在没有找到属性的情况下，会调用类的__getattr__属性 callable()函数可以测试一个变量是否可以调用（是否是函数） python有很多__XX__类型在函数中，都是可以定制的，有很大用处 枚举类，定义唯一实例的方法，比如无法改变值得常量时（类似宏定义），如： 123from enum import EnumMonth=enum('Month','Jan','Feb','Mar')#还可以通过@unique来确定每个值都唯一 python在载入模块时，动态创建关于该模块的class type()函数可以返回对象的类型，也可以创建新的类型 12345def fn(self) print('great')Hello=type('Hello',(object),dict(hello=fn))Hello.hello()#type()接收三个参数，class名称、父类、属性 metaclass在创建类的时候，动态执行metaclass如： 1234567class ListMetaclass(type):#一般继承type def __new__(cls, name, bases, attrs): #需定义new方法，在创建类的时候执行 attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) #返回值为当前准备创建类的对象、类的名字、类继承父类的集合、类的方法和属性的集合 错误处理 try...except...finally执行情况为try，遇到错误执行except，无论有没有错误，finally都会执行，也可以有多个except，try执行成功后，可以在except中加else执行。 错误抛出其实是一个类，因此，except父类后，子类不会执行，点击这里查看错误继承关系和类型。 解释器也会抛出错误，但是程序会中断执行，可以通过logging模块来记录错误，而且不会影响程序执行 raise可以抛出错误 可以通过pdb来进行单步调试 进行错误调试有三种方法，logging、print、assert 单元测试和文档测试自己使用时在学习吧孩子 IO编程 文件读写常用的四个函数open(path,&#39;rb/wb/...&#39;,encoding=&#39;..&#39;,error=&#39;...&#39;),read()/readlines()/readline(),write()类似read,close() 在文件写入的过程中，一般是将写入内容先保存在内存中，等到空闲时再存入硬盘，因此，为了保险，必须要使用close()方法来保证写入到硬盘中。 可以通过try方式，但更推荐with： 12345678910try: f=open('/path/to/file','r') #open()方法返回read()方法的对象称为file-like object,不需要从特定的类继承，只需要有read()方法就行 f.read()finally: if f: f.close()#with方式with open('/path/to/file','r') as f: f.read() StringIO、BytesIO是在内存中读写的方式 os,os.path模块内置了大量目录操作的函数，赋值等操作在shutil模块中，不过应该是要下载 pickle了解就行 更常用的序列化的方式为json，与pickle一样，也有dumps、dump、load、loads，没加s为file-like object，但是注意class要进行定制，因为无法直接转换，序列化可以根据class的__dict__，但注意__slots__有的话就不行，或者需要自己写函数（可以查看dumps的文档），load则需要直接写函数，然后赋给load参数object_hook 进程和线程 一个进程最少有一个线程 多任务实现有三种方式： 多线程 多进程 多进程+多线程 Unix系统中，可以通过fork函数来创建子进程，fork()函数返回两次，其中子进程返回为0，父进程返回子进程pidId：如： 12345678import osprint('Process (%s) start...' % os.getpid())# Only works on Unix/Linux/Mac:pid = os.fork()if pid == 0: print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) 运行结果如下： Process (876) start…I (876) just created a child process (877).I am child process (877) and my parent is 876. 要实现跨平台的多进程，可以使用multiprocess模块来实现，同时可以通过pipe、queue来进行进程之间的通信 多线程由于有GIL锁因此无法有效利用多核，但是多进程这没有这个问题，每个进程都有自己独立的GIL锁 线程之间变量是共享的，但是每个进程会复制全局变量，互不影响 线程创建可以通过_thread，threading模块来实现，为了防止线程之间将全局变量改错，可以通过lock来加锁，两个方法lock.acquire()，lock.release() threading.local为每个不同的变量提供了方法（线程中），解决了参数在一个线程中各个函数之间互相传递的问题。 多进程相较于多线程更稳定，但消耗更大 计算密集型常用语C语言编写，IO密集型则用脚本语言 python有模块可以直接进行分布式进程managers 正则表达式 正则的写法和Javascript一样 正则匹配的方式是贪婪匹配，即尽可能匹配到更多的字符串，因此要使用尽可能少的匹配，可以在正则后边加? 通过引入re模块来干更多的事情：match方法，split方法，re.compile(正则表达式)，match.groups(),match.group()[group(0)永远返回匹配的所有字符] 注：virtualenv模块为应用提供了隔离的Python运行环境，解决了不同应用间多版本的冲突问题。 网络编程 一个socket表示打开了一个网络连接 TCP建立的连接时双向的，发送请求的为客户端 服务器为了保证尽可能多的请求接收到，因此每个连接对应一个线程 socket.recv/socket.connnect/socket.socket/socket.send是几个常用方法 服务器端增加了socket.bind()/socket.acquire()方法 UDP是UDP则是面向无连接的协议。look here WEB开发 浏览器是根据content-type来判断文件类型，并不是根据URL如：http://www.sina.com/abc.jpg并不一定代表就是图片 跟踪了新浪的首页，我们来总结一下HTTP请求的流程：步骤1：浏览器首先向服务器发送HTTP请求，请求包括：方法：GET还是POST，GET仅请求资源，POST会附带用户数据；路径：/full/url/path；域名：由Host头指定：Host: www.sina.com.cn以及其他相关的Header；如果是POST，那么请求还包括一个Body，包含用户数据。步骤2：服务器向浏览器返回HTTP响应，响应包括：响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；响应类型：由Content-Type指定；以及其他相关的Header；通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。 HTTPget的请求方式为：GET /path HTTP/1.1 每个Header一行一个，换行符是\\r\\n 当遇到连续两个\\r\\n时，Header部分结束，后面的数据全部是Body。 HTTP响应如果包含body，也是通过\\r\\n\\r\\n来分隔的。请再次注意，Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据 Web Server Gateway Interface(WSGI)给我们提供了TCP等建立连接的接口，方便我们编程，通过以下函数，就可以直接响应HTTP请求 123def application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'] 如上，environ包含了请求中所有的输入信息，start_response只能运行一次，第一个参数返回响应信息，其他header信息通过第二个参数以list的形式发送（里边包tuple） application可以通过自己写的server端调用（要包含WSGI服务器来调用） 使用flask框架可以将我们的注意力从WSGI转移到URL对函数的映射上来，从而简化，常用于flask模板的有jinja2、Djino","categories":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"https://huianyi.github.io/tags/Python/"}]},{"title":"C-笔记","slug":"C-笔记","date":"2016-03-26T08:17:00.000Z","updated":"2018-02-07T07:28:13.354Z","comments":true,"path":"2016/03/26/C-笔记/","link":"","permalink":"https://huianyi.github.io/2016/03/26/C-笔记/","excerpt":"","text":"八进制表示方法：0… 十六进制表示方法：0x… printf中使用%0、%x、%#0、%#x、%#X来表示 八进制和十六进制（#x会输出0X） unsigned int 表示无负数的整数类型，包含了从0到65535 %u 表示unsigned int L/l 可以将一个较小的数以long形式存储 比如int a=23L，同样适用于八进制和十六进制 %ld 打印long类型，有些系统中int和long代表的字节数相同，故可以使用%d，但是也会出现不一样的情况 %hd 表示short C把一个字节定为char类型使用的位数 %c显示字符，注意printf()函数主要是显示方式而不是存储方式 浮点常量可以省略纯小数部分或纯整数部分，但不能同时省略，也可以省略小数点或指数部分，但不能同时省略。注意：数字中间不能出现空格 默认将浮点常量当做double精度型，但可以在常量后边增加f/F来表示float型，也可以加入L/l来表示long double %f、%e、%a为浮点的表示 卷子问题整理 软件测试是为了发现错误而执行程序的过程，测试要以查找错误为中心，而不是为了演示软件的正确功能 需求获取、需求分析、编写需求规格说明书、需求评审——需求分析阶段的工作 软件的生命周期是指软件产品从提出、实现、使用维护到停止使用退役的过程 软件的生命周期可以分为软件定义、软件开发与软件运行维护三个阶段，其中主要活动阶段是：可行性研究与计划阶段、需求分析、软件设计、软件实现、软件测试、运行与维护。 数据库中内模式是物理模式，它给出了数据库物理存储结构与物理存取方法 switch语句的执行总是遇到break才终止，否则顺序执行 位运算符的相关知识 数据字典的相关知识（是在需求分析阶段建立，在数据库设计过程中不断修改、充实和完善的） 面向对象基本方法的基本概念有对象、类和实例、消息、继承与多态性 宏定义只是做简单替换的一种方法 文件是由数据序列组成，可以构成二进制文件或文本文件 各变量类型的字节长度 变量类型 32位 64位 char 1 1 int 4 大多数4，少数8 long 4 8 float 4 4 double 8 8 指针 4 8 循环队列是队列中的一种顺序存储结构 数据库中的相关知识 软件危机主要表现在：软件需求的增长得不到满足;软件开发成本和进度无法控制；软件质量难以保证；软件不可维护或维护程度非常低；软件成本不断提高；软件开发成产率的提高赶不上硬件的发展和应用需求的增长 黑盒测试是对软件已经实现的功能是否满足要求进行的测试和验证，不考虑内部特性，只根据程序的需求和规格说明，检查程序的功能 软件设计中使用的工具有：系统结构图（需求分析阶段）、PAD、程序流程图是在详细设计阶段用到的；数据流图（DFD）是在结构化分析方法中用到的 程序模块化思想：把程序分成软噶相对独立、功能单一的模块以便重复使用和编码调试；采用自顶向下，逐步细化的设计方法。 运算符的优先级 数组的定义方法 函数未说明类型的情况下，自动按照int类型处理 在printf中使用%%来表示%号 浮点数取模是无效的 浮点数运算也可以使用关系运算符，但最好使用&lt; &gt;,不要使用&lt;= &gt;=,因为浮点数运算是不准确的 算术运算符&gt;关系运算符&gt;赋值运算符 预定义标识符可以作为用户标识符（define/main/printf/scanf）","categories":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/tags/笔记/"},{"name":"C","slug":"C","permalink":"https://huianyi.github.io/tags/C/"}]},{"title":"数据挖掘导论","slug":"数据挖掘导论","date":"2016-03-15T00:41:00.000Z","updated":"2018-02-07T06:27:37.309Z","comments":true,"path":"2016/03/15/数据挖掘导论/","link":"","permalink":"https://huianyi.github.io/2016/03/15/数据挖掘导论/","excerpt":"本文为《数据挖掘导论》笔记，目前仅有前三章内容，不定期持续更新中…","text":"本文为《数据挖掘导论》笔记，目前仅有前三章内容，不定期持续更新中…四中主要的数据挖掘任务： 聚类分析 预测分析 关联分析 异常检测 第二章：数据数据集的特性： 维度：数据预处理主要目的就是降低维度（防止维灾难）维归约 稀疏度 分辨率：主要是时间刻度 数据挖掘着眼于两个方面 对数据质量问题进行检测和纠正 研究可以容忍低质量数据的算法 数据预处理 聚集：将两个或多个对象合并成一个对象——对象或属性群之间的行为通常比单个对象更稳定 抽样：注意选定合适的样本容量（可以通过渐进抽样的方法），以及由于属性之间的关系选择分层抽样，使用聚类等方法 维归约：减少属性值，从而降低数据挖掘对内存和时间复杂度上的需求：维归约的线性代数技术——主成分分析/奇异值分解 特征子集选择：嵌入/过滤/包装方法特征子集选择体系结构如下图所示： 特征创建 特征提取 映射数据到新的空间：小波变换、傅里叶变换 特征构造 离散化和二元化：二元化常用的方法（P49），非监督离散化——等宽、等频率、等深；监督离散化——利用熵来进行判断；具有过多值的分类属性——可以采用离散化的方法，也可以根据数据的特征进行大类的划并（如工程学系、社会科学系） 变量变换：简单函数变化；规范化和标准化（利用中值取代均值，绝对标准差取代标准差 相似性和相异性的度量 相似度常取值为0到1，而相异度则有时在0到1，有时会大于1 简单属性的相似性和相异性测量 标称属性只携带了对象的相异性信息 具有单个标称属性的对象之间的相异性完全可以根据标称属性判断 对于具有单个序数对象的属性，就要对序数进行量化，常见的定义序数属性邻近度的标准方法是1,2,3,4… 区间或比率属性相异度测量的方法是属性值相减的绝对值，一般说来，区间或比率的相似度常转化为相异度进行测量 如图： 数据对象之间的相似度和相异度 欧几里得距离为 $d(x,y)=\\sqrt{\\sum\\limits_{k=1}^n(x_k-y_k)^2}$,这个式子可以由下式推广： d(x,y)=\\left(\\sum_{k=1}^n|x_k-y_k|^r\\right)^{\\frac1r}\\text(闵可夫斯基距离)注意： $r$是参数，不要和属性个数进行混淆 当$r\\rightarrow\\infty$时，可以得出距离L的最大值$L_\\infty$ L_{max}=\\lim_{r\\rightarrow\\infty}\\left(\\sum_{k=1}^n|x_k-y_k|^r\\right)^{\\frac1r} 距离具有如下属性： 非负性 对称性 三角不等式性：对于$x、y、z$,有$d(x,z)\\leq d(x,y)+d(y,z)$满足上边属性的称为度量 遇到有些非度量的，就无法使用距离公式，一般要根据具体情境考虑，如集合差、时间 数据之间的相似度见P58 邻近性度量的例子 二元数据的相似性度量 简单匹配系数(SMC)f_{00}表示x与y属性都为0的个数； f_{01}表示x为0y为1的个数； f_{10}、f_{11}依次同上则有：SMC=\\frac {f_{00}+f_{11}}{f_{00}+f_{11}+f_{01}+f_{10}} Jaccard系数，排除了SMC方法0过多时导致所有属性都是相似的问题：J=\\frac {f_{11}}{f_{10}+f_{01}+f_{11}} 非二元属性的相似性度量 余弦相似度不仅忽略了0过多的问题，而且考虑了非二元属性，常用语文档相似度分析，如果x和y表示两个文档属性，则有： \\cos(x,y)=\\frac {x \\cdot y}{||x||||y||}其中$||x||=\\sqrt{\\sum\\limits{k=1}^nx_k^2}$、$x\\cdot y=\\sum{k=1}^nx_ky_k$ 广义Jaccard系数 EJ(x,y)=\\frac {x\\cdot y}{||x||^2+||y||^2-x\\cdot y} 相关性：两个具有二元属性或连续变量的数据对象之间的相关性就是对象属性之间线性联系的度量，更准确的说就是皮尔森相关系数，如下：corr(x,y)=\\frac {S_{xy}}{S_xS_y}S_{xy}=\\frac 1{n-1}\\sum_{k=1}^n(x_k-\\bar x)(y_k-\\bar y)S_x=\\sqrt{\\frac 1{n-1}\\sum_{k=1}^n(x_k-\\bar x)^2}$S_y$同理 Bregman散度 邻近度计算的相关问题 属性值域不同或者之间有相关性Mahalanobis距离：常用来计算有相关性的属性之间的距离：Mahalanobis(x,y)=(x-y)\\sum\\nolimits^{-1}(x-y)^T其中$\\sum\\nolimits^{-1}$表示向量x和y的协方差矩阵的逆，协方差矩阵指的是第$ij$个元素满足$x_i$和$y_j$属性的协方差值域不同时通过标准化使用欧几里得距离就好 数据对象之间属性的数据类型不相同时： 使用权值similarity(x,y)=\\frac {\\sum_{k=1}^nw_k\\delta_ks_k(x,y)}{\\sum_{k=1}^n\\delta_k}d(x,y)=\\left(\\sum_{k=1}^nw_k\\left|x-y\\right|^r\\right)^\\frac 1r其中$w_k$的权值和为1。 选取度量时的常用方法 对于稠密、连续的数据通常使用距离 稀疏数据，常常进行忽略0-0这些属性的方法，这反映了如下事实，相似度通常依赖于他们所共有的性质项目，而不是依赖于他们所缺失的项目 考虑数据的时间延迟，为了得到合适的数据相似度度量，常常进行数据的基本处理 第三章：探索数据 数据探索，对数据进行初步研究，以便更好地理解它的特殊性质。数据探索有助于选择合适的数据预处理和数据分析技术。他甚至可以处理一些通常有数据挖掘解决的问题，例如，有时可以通过对数据直接检查发现模式，此外，数据探索中使用的某些技术可以用于理解和解释数据挖掘结果。 截断均值：指定0~100之间的百分位数p，丢弃高端和低端$\\frac p2$%的数据，然后再取均值 Rt=\\frac{invest\\_total}{income\\times market\\_in\\ age}","categories":[{"name":"笔记","slug":"笔记","permalink":"https://huianyi.github.io/categories/笔记/"}],"tags":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://huianyi.github.io/tags/数据挖掘/"}]},{"title":"LaTeX公式的使用教程","slug":"LaTeX公式的使用教程","date":"2015-11-08T02:17:00.000Z","updated":"2018-02-07T06:34:59.457Z","comments":true,"path":"2015/11/08/LaTeX公式的使用教程/","link":"","permalink":"https://huianyi.github.io/2015/11/08/LaTeX公式的使用教程/","excerpt":"转载自翻译文章，由于年代久远，忘记了原地址了，如果有人知道，还望通知： 本文从math.stackexchange.com上名为MathJax basic tutorial and quick reference的问题翻译而来，并有所改动。主要讲述了如何使用Latex语法。","text":"转载自翻译文章，由于年代久远，忘记了原地址了，如果有人知道，还望通知： 本文从math.stackexchange.com上名为MathJax basic tutorial and quick reference的问题翻译而来，并有所改动。主要讲述了如何使用Latex语法。 公式 $$表示独自成为一个段落 $表示为行间 希腊字母 名称 大写 Tex 小写 Tex alpha A A α \\alpha beta B B β \\beta gamma Γ \\Gamma γ \\gamma delta Δ \\Delta δ \\delta epsilon E E ϵ \\epsilon zeta Z Z ζ \\zeta eta H H η \\eta theta Θ \\Theta θ \\theta iota I I ι \\iota kappa K K κ \\kappa lambda Λ \\Lambda λ \\lambda mu M M μ \\mu nu N N ν \\nu xi Ξ \\Xi ξ \\xi omicron O O ο \\omicron pi Π \\Pi π \\pi rho P P ρ \\rho sigma Σ \\Sigma σ \\sigma tau T T τ \\tau upsilon Υ \\Upsilon υ \\upsilon phi Φ \\Phi ϕ \\phi chi X X χ \\chi psi Ψ \\Psi ψ \\psi omega Ω \\Omega ω \\omega 上标和下标 _表下标 ^表示上标 块间使用{} 小括号和中括号使用原始的就好 注意使用\\{表示大括号 上取整：使用\\lceil 和 \\rceil 表示 如$\\lceil x \\rceil$ 下取整：使用\\rfloor 和\\lfloor 表示 如$\\lfloor x \\rfloor$注意： 中间要有空格 不可见括号：使用.表示 原始符号并不会随着公式大小缩放，因此要使用\\left(...\\right)表示比如: \\lbrace\\sum_{i=0}^n i^2 = >\\frac{(n^2+n)(2n+1)}{6}\\rbrace就可以改为： \\left \\lbrace \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}\\right\\rbrace 求和与积分\\sum用来表示求和符号，其下标表示求和下限，上标表示上限。如:$\\sum_1^n$。 \\int用来表示积分符号，同样地，其上下标表示积分的上下限。如，$\\int_1^\\infty$ 与此类似的符号还有，\\prod：∏，\\bigcup:⋃，\\bigcap：⋂，\\iiint:$\\iiint$ 分式与根式分式可以用\\frac表示，比如$\\frac ab$,根式使用\\sqrt[数字]表示，比如：$\\sqrt\\frac ab$ 字体 使用\\mathbb或\\Bbb显示黑板粗体字，此字体经常用来表示代表实数、整数、有理数、复数的大写字母。如：$\\mathbb CHNQRZ$、$\\Bbb CHNQRZ$。 使用\\mathbf显示黑体字，如： $\\mathbf anbcedfghig$。 使用\\mathtt显示打印机字体，如： $\\mathtt andfjdsaf$。 使用\\mathrm显示罗马字体，如，$\\mathrm wxyz$。 使用\\mathscr显示手写体，如，$\\mathscr dfjalsfa$。 使用\\mathfrak显示Fraktur字母（一种德国字体），如: $\\mathfrak dfasfasf$ 特殊符号和函数 常见的三角函数，求极限符号可直接使用\\+缩写即可。如:$\\sin x$ $ \\lim_{1\\to\\infty}$ 比较运算符\\lt \\gt \\le ge \\neq,如: $a\\lt b$ $a\\gt c$ $a \\le b$ $a \\ge c$ $a\\neq b$,若需要不等号，则只需加上\\not即可，如： $\\not\\lt$ \\times \\div \\pm \\mp表示：$\\times$ $\\div$ $\\pm$ $\\mp$，\\cdot表示居中的点，x \\cdot y :$x \\cdot y$。 集合关系与运算：\\cup \\cap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing ：$\\cup$ $\\cap$ $\\setminus$ $\\subset$ $\\subseteq$ $\\subsetneq$ $\\supset$ $\\in$ $\\notin$ $\\emptyset$ $\\varnothing$ 表示排列使用{n+1 \\choose 2k} 或 \\binom{n+1}{2k}，$\\binom{n+1}{2k}$ 箭头：\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto : $\\to\\rightarrow\\leftarrow\\Rightarrow\\Leftarrow\\mapsto$ 逻辑运算符：\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash $\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash$ \\star \\ast \\oplus \\circ \\bullet :$\\star \\ast \\oplus \\circ \\bullet $ \\approx \\sim \\cong \\equiv \\prec:$\\approx \\sim \\cong \\equiv \\prec$ \\infty \\aleph_0: $\\infty \\aleph_0$ \\nabla \\partial: $ \\nabla \\partial$ \\Im \\Re: $\\Im \\Re$ 模运算 \\pmod: $a\\equiv b\\pmod n$ \\ldots与\\cdots，其区别是dots的位置不同，ldots位置稍低，cdots位置居中:$a+b+c+\\cdots+z$,$a,b,c,d,\\ldots,z$ 一些希腊字母具有变体形式，如 \\epsilon \\varepsilon:$\\epsilon$ $\\varepsilon$ 空间通常MathJax通过内部策略自己管理公式内部的空间，因此ab与a b（.表示空格）都会显示为ab。可以通过在ab间加入\\,增加些许间隙，\\;增加较宽的间隙，\\quad 与 \\qquad 会增加更大的间隙，如，$a\\ b$(注意\\后边跟上字母也得加空格) $a\\; b$ $a\\quad b$。 顶部符号对于单字符，\\hat:$\\hat b$,多字符\\widehat:$\\widehat {ab}$,类似的还有:\\overline,\\vec,\\overrightarrow,\\dot \\ddot:$\\overline {abc}\\ \\vec {av}$(只能输两个)$\\overrightarrow {adc}\\ \\dot d$(只能输一个) $\\ddot a$(只能输一个) 结束基础部分就是这些。需要注意的是一些MathJax使用的特殊字符，可以使用\\转义为原来的含义。如\\$表示$，\\_表示下划线. 表格使用$$\\begin{array}{列样式}…\\end{array}$$这样的形式来创建表格，列样式可以是c表示居中，l左，r右对齐，还可以使用|表示一条竖线。表格中 各行使用\\\\分隔，各列使用&amp;分隔。使用\\hline在本行前加入一条直线。 例如， 1$$ \\begin&#123;array&#125;&#123;c|lcr&#125; n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end&#123;array&#125; $$ 结果: \\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}更复杂的有： \\begin{array}{c}\\begin{array}{cc}\\begin{array}{c|cccc}\\text{min} & 0 & 1 & 2 & 3\\\\\\hline 0 & 0 & 0 & 0 & 0\\\\1 & 0 & 1 & 1 & 1\\\\2 & 0 & 1 & 2 & 2\\\\3 & 0 & 1 & 2 & 3\\end{array}&\\begin{array}{c|cccc}\\text{max}&0&1&2&3\\\\\\hline0 & 0 & 1 & 2 & 3\\\\1 & 1 & 1 & 2 & 3\\\\2 & 2 & 2 & 2 & 3\\\\3 & 3 & 3 & 3 & 3\\end{array}\\end{array}\\\\\\begin{array}{c|cccc}\\Delta&0&1&2&3\\\\\\hline0 & 0 & 1 & 2 & 3\\\\1 & 1 & 0 & 1 & 2\\\\2 & 2 & 1 & 0 & 1\\\\3 & 3 & 2 & 1 & 0\\end{array}\\end{array}矩阵基本用法使用$$\\begin{matrix}…\\end{matrix}$$这样的形式来表示矩阵，在\\begin与\\end之间加入矩阵中的元素即可。矩阵的行之间使用\\\\分隔，列之间使用&amp;分隔。 例如 $$ \\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix} $$ 结果： \\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}加括号如果要对矩阵加括号，可以像上文中提到的一样，使用\\left与\\right配合表示括号符号。也可以使用特殊的matrix。即替换\\begin{matrix}…\\end{matrix}中的matrix为pmatrix，bmatrix，Bmatrix，vmatrix , Vmatrix.如： pmatrix:$\\begin{pmatrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \\end{pmatrix}$,bmatrix:$\\begin{bmatrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \\end{bmatrix}$,Bmatrix:$\\begin{Bmatrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \\end{Bmatrix}$,vmatrix：vmatrix$\\begin{vmatrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \\end{vmatrix}$,Vmatrix：$\\begin{Vmatrix}1&amp;2\\3&amp;4\\ \\end{Vmatrix}$(这里有问题，需验证) 省略元素可以使用\\cdots $\\cdots$ \\ddots $\\ddots$ \\vdots $\\vdots$ 来省略矩阵中的元素，如 \\begin{pmatrix} 1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\ \\vdots & \\vdots& \\vdots & \\ddots & \\vdots \\\\ 1 & a_m & a_m^2 & \\cdots & a_m^n\\end{pmatrix}增广矩阵增广矩阵需要使用前面的array来实现，如 $$ \\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array} \\right] $$ 结果 \\left[ \\begin{array}{cc|c} 1&2&3\\\\ 4&5&6 \\end{array} \\right]对齐的公式有时候可能需要一系列的公式中等号对齐，如： \\begin{align}\\sqrt{37}&=\\sqrt{\\frac{73^2-1}{12^2}}\\\\&=\\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\\end{align}公式如下： \\begin{align}\\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ &amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align} 分类表达式定义函数的时候经常需要分情况给出表达式，可使用\\begin{cases}…\\end{cases}。其中，使用\\来分类，使用&amp;指示需要对齐的位置。如: f(n) =\\begin{cases}n/2, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd} \\\\\\end{cases} f(n)=\\begin{cases}n/2,&\\text{if $n$ is even} \\\\3n+1, & \\text{if $n$ is odd}\\\\\\end{cases}括号移到右边(用array实现) \\left.\\begin{array}{l}\\text{if $n$ is even:}&amp;n/2\\\\\\text{if $n$is odd:}&amp;3n+1\\end{array}\\right\\}=f(n) \\left.\\begin{array}{l}\\text{if $n$ is even:}&n/2\\\\\\text{if $n$ is odd:}&3n+1\\end{array}\\right\\}=f(n)最后，如果想分类之间的垂直间隔变大，可以使用\\[2ex]代替\\来分隔不同的情况。(3ex,4ex也可以用，1ex相当于原始距离） 注意事项详见：markdown教程","categories":[{"name":"教程","slug":"教程","permalink":"https://huianyi.github.io/categories/教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://huianyi.github.io/tags/教程/"},{"name":"LaTex","slug":"LaTex","permalink":"https://huianyi.github.io/tags/LaTex/"}]},{"title":"markdown-tutorial","slug":"markdown-tutorial","date":"2015-11-07T13:40:00.000Z","updated":"2018-02-07T06:16:54.376Z","comments":true,"path":"2015/11/07/markdown-tutorial/","link":"","permalink":"https://huianyi.github.io/2015/11/07/markdown-tutorial/","excerpt":"介绍markdown基本语法与使用规范","text":"介绍markdown基本语法与使用规范 这是一个一号标题这是一个二号标题这是一个三号标题这是一个四好标题这是一个五号标题这是一个六号标题1234567891011# 这是一个一号标题## 这是一个二号标题### 这是一个三号标题#### 这是一个四好标题##### 这是一个五号标题###### 这是一个六号标题 无序列表1 无序列表2 无序列表3 有序列表1 有序列表2 有序列表3 1234567- 无序列表1- 无序列表2- 无序列表31. 有序列表12. 有序列表23. 有序列表3 baidu 12[baidu](http://www.baidu.com)![笔记](https://raw.githubusercontent.com/huianyi/-markdown-png/master/datamining.jpg) 这是一个引用要不再来一次注意要保留一个空格 123&gt; 这是一个引用&gt; 要不再来一次&gt; 注意要保留一个空格 注意如果想让引用保留另起一段的格式，可用如下方式：可以多加一行空格 123456&gt; 这是一个引用&gt;&gt; 要不再来一次&gt;&gt; 注意要保留一个空格&gt; 效果： 这是一个引用 要不再来一次 注意要保留一个空格 一个``为斜体* 两个``为粗体** 注意： 要引用诸如*在文本中，可以使用\\进行转义 表格：| Tables | Are | Cool ||:———————-:|:———————-|———-|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 12345| Tables | Are | Cool ||:---------------:|:---------------|-------|| col 3 is | right-aligned | \\$1600 || col 2 is | centered | \\$12 || zebra stripes | are neat | \\$1 | 在文章中使用代码时，用```代码名表示，结束用``` ,可在末尾增加代码名。 规范注意两点： 别乱加空格、空行 一般不同类型的之间有一个空行 官方规范地址：mdRules","categories":[{"name":"教程","slug":"教程","permalink":"https://huianyi.github.io/categories/教程/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://huianyi.github.io/tags/markdown/"},{"name":"tutorial","slug":"tutorial","permalink":"https://huianyi.github.io/tags/tutorial/"}]}]}